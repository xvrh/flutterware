
1/ bin to start server
2/ independent app which connect to server (mac0S + Web)
3/ Server listen websocket & server precompiled web app
4/ manage "flutter run" client
5/ Read all dart file ending with _test.dart in "test_studio" folder
6/ Generate an entry point to import everything (and update)
7/ Runtime with the WidgetTester api

1rst goal:
 - Run the full flutter_gallery (Have some files & some group & test to go to every screen of the gallery)
 - Socialize the general idea and get a sense of the attractiveness
 - Provide a readme with attractive screenshots & a web page.

2nd goal:
 - Able to migrate the current dev_studio to this OSS version
    => consolidate one single version
    => prove that it can be useful
    => check custom integration is possible
    => Check to add it to BR to test how easy/hard it is to use on existing project.

    => custom translations system
    => custom analytic system
    => assets etc...

 - Examples (flutter gallery) + custom will be deployed in total isolation so it needs to work
   on stock flutter project

Think about a High level API more tailored for full-app testing like that (auto pump)

```dart
await tester.tap(find.by(SomeType));
await tester.pumpAndSettle();
await tester.screenshot();
```

We also offer a simpler API. This alternative API is more tailored to the kind of high level testing targeted by this tool.
```dart
class MyScenario extends Scenario {
  @override
  void run() {
    tap(SomeType);
    screenshot(); // Optional?
  }
}
```
```dart
class MyScenario extends Scenario {
  @override
  void run() {
    tap(SomeType);
    withoutScreenshots(() {
      tap(SomeType);
    });
    scroll(SomeType, down: 300, screenshot: false);

    screenshot = false;
    tap(translations.someText);
    screenshot = true;
  }
}
```

- Try to remove "await"
-

Explain "mocking"

To achieve this, you'll need to use a "dependency injection" technic with a mock or fake implementation.
In your test context, any external interaction will need to be mocked.
ie. Network/API request, OS native API, Bluetooth, ...

Example of mocking: (link to each example of code)
- Use mockito to mock API requests
- Use a Fake to mock Bluetooth peripherals
- Use a stub to hardcode some OS capabilities (geocoding, device_info,...)
- Use a mock for the permission plugin
- Use a mock of the database

This requires some discipline but the reward could be worth it...

Example of workflow:
- Run all your tests on a pull request
- Deploy a web app showing all your screen for each pull request on Github
- Take a screenshot of every corner of your app and publish it automatically as documentation to Confluence.



